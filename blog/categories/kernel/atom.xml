<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kernel | Gavin Guo]]></title>
  <link href="http://bboymimi.github.io/blog/categories/kernel/atom.xml" rel="self"/>
  <link href="http://bboymimi.github.io/"/>
  <updated>2017-08-12T22:43:42+08:00</updated>
  <id>http://bboymimi.github.io/</id>
  <author>
    <name><![CDATA[Gavin Guo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[10 Steps to Submit Patches to the Ubuntu Kernel]]></title>
    <link href="http://bboymimi.github.io/blog/2017/08/12/10-steps-to-submit-patches-to-the-ubuntu-kernel/"/>
    <updated>2017-08-12T22:17:42+08:00</updated>
    <id>http://bboymimi.github.io/blog/2017/08/12/10-steps-to-submit-patches-to-the-ubuntu-kernel</id>
    <content type="html"><![CDATA[<p>[Ubuntu Kernel 攻略 - 十個步驟讓你送patch到Ubuntu kernel]
<a href="https://twlinuxkernelhackers.hackpad.com/ma0mqwjifEs%E2%80%A6">https://twlinuxkernelhackers.hackpad.com/ma0mqwjifEs%E2%80%A6</a>
一般distribution kernel使用的版本比較舊，各個distribution需要完善kernel的穩定性，會持續的backport bug-fix到自己的kernel版本。以Ubuntu來說目前線上的kernel版本有
Ubuntu 12.04 Precise 3.2 (2012 04發行)
Ubuntu 14.04 Trusty 3.13 (2014 04發行)
Ubuntu 14.10 Utopic 3.16 (2014 10發行)
Ubuntu 15.04 Vivid 3.19 (2015 04發行)
其中Precise和Trusty是LTS的版本，分別support 五年。Precise到2017，Trusty到2019。如果自己要安裝server的話，建議用LTS的版本，會有比較長的maintainance。
詳見下圖：
<a href="https://wiki.ubuntu.com/Kernel/LTSEnablementStack">https://wiki.ubuntu.com/Kernel/LTSEnablementStack</a>
接下來切入主題，要如何送patch做backport，也就是俗稱的SRU(Standard Release Update)程序[3]。一般Ubuntu kernel是不收沒有上Upstream的patch，所以要記得先送kernel upstream再cherry-pick回來。拿個自己的bug為例 <a href="https://lkml.org/lkml/2015/4/23/228%EF%BC%9A">https://lkml.org/lkml/2015/4/23/228%EF%BC%9A</a>
commit 4066c33d0308f87e9a3b0c7fafb9141c0bfbfa77
Author: Gavin Guo <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x67;&#97;&#x76;&#105;&#110;&#x2e;&#103;&#117;&#x6f;&#x40;&#99;&#x61;&#x6e;&#111;&#x6e;&#x69;&#99;&#x61;&#x6c;&#x2e;&#99;&#x6f;&#109;">&#103;&#97;&#x76;&#x69;&#110;&#x2e;&#x67;&#117;&#111;&#x40;&#x63;&#97;&#110;&#111;&#110;&#105;&#x63;&#x61;&#x6c;&#x2e;&#x63;&#x6f;&#109;</a>
Date: Wed Jun 24 16:55:54 2015 -0700
mm/slab_common: support the slub_debug boot option on specific object size
因為slub_debug在實作上有些問題，導致沒有辦法把slub_debug限制在某些object size上面。上面commit是bug fix。由git show可以知道這是在June 24才剛進去mainline(在v4.2-rc1的merge windows裡面)。因此所有的Ubuntu release都受影響。進而需要backport這個commit到所有的Ubuntu release。最後因為某些原因，SRU只做Trusty, Utopic, and Vivd。
1) 先到 launchpad的linux package開個public bug:
support the slub_debug boot option on specific object size
<a href="https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1456952">https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1456952</a>
在bug description[1]裡面記得填寫
並且加入這個bug影響的release到tags，ex: Trusty, Utopic, and Vivid.
2) 到 <a href="http://kernel.ubuntu.com/git/?ofs=650">http://kernel.ubuntu.com/git/?ofs=650</a> 找到Trusty的tree
git://kernel.ubuntu.com/ubuntu/ubuntu-trusty.git</p>

<h1>clone trusty的kernel tree到本地端</h1>

<p>git clone git://kernel.ubuntu.com/ubuntu/ubuntu-trusty.git
git remote add linus git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
git fetch linus
3) 分別針對Trusty, Utopic, and Vivid 複製一份 branch
git checkout -b backport-trusty-1456952 origin/master
git checkout -b backport-utopic-1456952 origin/lts-backport-utopic
git checkout -b backport-vivid-1456952 origin/lts-backport-vivid
4) cherry-pick commit到本地的branch
值得一提的是-x 會把commit 最後加上
(cherry picked from commit 4066c33d0308f87e9a3b0c7fafb9141c0bfbfa77)
可以很清楚的知道這個cherry-picked commit來自upstream的哪個commit id
git cherry-pick -s -x 4066c33d0308 -e</p>

<h1>-e 有加上所以會進入edit mode。之後在 commit title 之後空一列加入</h1>

<h1>BugLink: <a href="http://bugs.launchpad.net/bugs/1456952">http://bugs.launchpad.net/bugs/1456952</a></h1>

<h1>這時候常常不會很順利可以clean cherry-picked，在fix完conflict，git add file, git cherry-pick &ndash;continue以後，要把commit裡面的cherry picked改成backported。並且用scripts/checkpatch.pl掃過確認沒有格式問題。</h1>

<p>5) 產生patch並且修改為Ubuntu patch格式[2]
git format-patch -1 &ndash;cover-letter</p>

<h1>這之後會在當下目錄生出</h1>

<p>0000-cover-letter.patch
0001-mm-slab_common-support-the-slub_debug-boot-option-on.patch
vim 0000-cover-letter.patch把Subject改成
[Trusty/Utopic/Vivid][SRU][ PATCH] LP#1456952 &ndash; mm/slab_common: support the slub_debug boot option on specific object size
commit message加入剛剛在bug description裡面寫的<a href="upstream%E7%9B%B8%E9%97%9C%E7%9A%84fix,">Impact</a><a href="%E5%A6%82%E4%BD%95%E6%B8%AC%E8%A9%A6">Test Case</a>。
0001-mm-slab_common-support-the-slub_debug-boot-option-on.patch patch的Subject也要加上[Vivid][SRU]。
在checkout到其他的branch之前記得把0001-mm-slab_common-support-the-slub_debug-boot-option-on.patch更名，免得format-patch會被蓋掉。因為Subject相同，所以patch名稱也會相同。再來就是checkout到backport-utopic-1456952和backport-trusty-1456952。個別再做一次cherry-pick，加入buglink。然後git format-patch -1，這次就不用加上&ndash;cover-letter。
如果真的不熟悉，可以到Ubuntu mailing list上面看看大家怎麼送的。慢慢就會知道格式怎麼寫。
6) build kernel並且測試cherry-picked commit是否工作正常[4]
fakeroot debian/rules clean binary-generic
sudo dpkg -i xxx.deb</p>

<h1>doing test cases</h1>

<p>7) 註冊Ubuntu kernel team mailing list
到 <a href="https://lists.ubuntu.com/mailman/listinfo/kernel-team">https://lists.ubuntu.com/mailman/listinfo/kernel-team</a> 註冊maillist之後就會收到Ubuntu kernel開發的email。
8) 用git送出patch到Ubuntu kernel mailing list
git send-email &ndash;no-chain-reply-to &ndash;suppress-cc all &ndash;to &ldquo;<a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x6b;&#x65;&#x72;&#110;&#x65;&#108;&#x2d;&#116;&#101;&#x61;&#x6d;&#x40;&#x6c;&#x69;&#x73;&#x74;&#115;&#x2e;&#x75;&#x62;&#117;&#110;&#116;&#117;&#46;&#99;&#x6f;&#x6d;">&#x6b;&#x65;&#114;&#110;&#101;&#108;&#45;&#x74;&#101;&#x61;&#x6d;&#64;&#108;&#x69;&#x73;&#x74;&#115;&#46;&#x75;&#98;&#x75;&#110;&#x74;&#x75;&#46;&#99;&#x6f;&#109;</a>&rdquo; 000* &ndash;force</p>

<h1>在送出patch之前，一定要先送一份到自己的mail，檢查有無錯誤內容。</h1>

<p>9) Waiting for Acks
在 kernel mailing list收到maintainers兩個人Ack以後就會被apply到你所tag的release git tree的master-next。然後進入到Proposed kernel。
10) Verification
最後等到proposed kernel出來以後，系統會寄mail通知你。這時候要下載ppa上面的proposed kernel來做測試(系統會自動寄出comment並且提供link做完整的說明)，看看是否解決了bug。如果測試通過則把剛剛所申請 launchpad bug 裡面的verification-needed tag改成verification-done。通過之後update版本就會包含這個patch。
Reference:
[1]. KernelUpdates <a href="https://wiki.ubuntu.com/KernelTeam/KernelUpdates">https://wiki.ubuntu.com/KernelTeam/KernelUpdates</a>
[2]. StablePatchFormat <a href="https://wiki.ubuntu.com/Kernel/Dev/StablePatchFormat">https://wiki.ubuntu.com/Kernel/Dev/StablePatchFormat</a>
[3]. A day in the life of a fixed bug <a href="https://wiki.edubuntu.org/Kernel/Dev/KernelBugFixing">https://wiki.edubuntu.org/Kernel/Dev/KernelBugFixing</a>
[4]. BuildYourOwnKernel <a href="https://wiki.ubuntu.com/Kernel/BuildYourOwnKernel">https://wiki.ubuntu.com/Kernel/BuildYourOwnKernel</a></p>

<h1>kernel #ubuntu #upstream #tlkh_upstream</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kernel Debugging 小技巧]]></title>
    <link href="http://bboymimi.github.io/blog/2017/08/12/kernel-debugging-xiao-ji-qiao/"/>
    <updated>2017-08-12T17:09:44+08:00</updated>
    <id>http://bboymimi.github.io/blog/2017/08/12/kernel-debugging-xiao-ji-qiao</id>
    <content type="html"><![CDATA[<p>（節錄自 Gavin Guo <a href="https://twlinuxkernelhackers.hackpad.com/Wiki-M37dy9c6AZt#:h=Debugging">原始貼文</a>）</p>

<h1>coredump</h1>

<p>相信很多時候在看到 coredump 的時候裡面會有一段：</p>

<pre><code>Code: 00 49 8b 50 08 4d 8b 28 49 8b 40 10 4d 85 
ed 0f 84 5a 01 00 00 48 85 c0 0f 84 51 01 00 00 
49 63 44 24 20 49 8b 3c 24 48 8d 4a 01 &lt;49&gt; 8b 5c 
05 00 4c 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 74 
b5 49
</code></pre>

<p>其實這個在沒有debug symbol的情況下可以利用kernel
source裡面的decodecode script快速的知道fault的問題所在：</p>

<pre><code class="bash">$ echo "Code: 00 49 8b 50 08 4d 8b 28 49 8b 40 10 
4d 85 ed 0f 84 5a 01 00 00 48 85 c0 0f 84 51 01 
00 00 49 63 44 24 20 49 8b 3c 24 48 8d 4a 01 &lt;49&gt; 
8b 5c 05 00 4c 89 e8 65 48 0f c7 0f 0f 94 c0 84 
c0 74 b5 49" | ./scripts/decodecode 
Code: 00 49 8b 50 08 4d 8b 28 49 8b 40 10 4d 85 
ed 0f 84 5a 01 00 00 48 85 c0 0f 84 51 01 00 00 
49 63 44 24 20 49 8b 3c 24 48 8d 4a 01 &lt;49&gt; 8b 5c 
05 00 4c 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 74 
b5 49
All code
========
0: 00 49 8b add %cl,-0x75(%rcx)
3: 50 push %rax
4: 08 4d 8b or %cl,-0x75(%rbp)
7: 28 49 8b sub %cl,-0x75(%rcx)
a: 40 10 4d 85 adc %cl,-0x7b(%rbp)
e: ed in (%dx),%eax
f: 0f 84 5a 01 00 00 je 0x16f
15: 48 85 c0 test %rax,%rax
18: 0f 84 51 01 00 00 je 0x16f
1e: 49 63 44 24 20 movslq 0x20(%r12),%rax
23: 49 8b 3c 24 mov (%r12),%rdi
27: 48 8d 4a 01 lea 0x1(%rdx),%rcx
2b:* 49 8b 5c 05 00 mov 0x0(%r13,%rax,1),%rbx &lt;-- trapping instruction
30: 4c 89 e8 mov %r13,%rax
33: 65 48 0f c7 0f cmpxchg16b %gs:(%rdi)
38: 0f 94 c0 sete %al
3b: 84 c0 test %al,%al
3d: 74 b5 je 0xfffffffffffffff4
3f: 49 rex.WB
Code starting with the faulting instruction
===========================================
0: 49 8b 5c 05 00 mov 0x0(%r13,%rax,1),%rbx
5: 4c 89 e8 mov %r13,%rax
8: 65 48 0f c7 0f cmpxchg16b %gs:(%rdi)
d: 0f 94 c0 sete %al
10: 84 c0 test %al,%al
12: 74 b5 je 0xffffffffffffffc9
14: 49 rex.WB
</code></pre>

<h1>crashdump</h1>

<p>一般我們在做 server 的 maintaining 的時候會從客戶那邊拿到 crashdump 的巨大 memory dump 檔案，之後再用 crash 這個 tool 打開，看 dmesg，撈 memory data，嘗試找出問題的所在。那麼如果你可以 access 到機器的情況下，有沒有辦法用 crash 來看當下的 memory data，進而檢查系統 work 的正不正常？？有的</p>

<pre><code>$ sudo apt-get install -y crash

$ sudo crash /usr/lib/debug/boot/vmlinux-3.13.0-48-generic --mod /usr/lib/debug/lib/modules/3.13.0-48-generic/ /proc/kcore

crash 7.0.3
Copyright (C) 2002-2013  Red Hat, Inc.
Copyright (C) 2004, 2005, 2006, 2010  IBM Corporation
Copyright (C) 1999-2006  Hewlett-Packard Co
Copyright (C) 2005, 2006, 2011, 2012  Fujitsu Limited
Copyright (C) 2006, 2007  VA Linux Systems Japan K.K.
Copyright (C) 2005, 2011  NEC Corporation
Copyright (C) 1999, 2002, 2007  Silicon Graphics, Inc.
Copyright (C) 1999, 2000, 2001, 2002  Mission Critical Linux, Inc.
This program is free software, covered by the GNU General Public License,
and you are welcome to change it and/or distribute copies of it under
certain conditions.  Enter "help copying" to see the conditions.
This program has absolutely no warranty.  Enter "help warranty" for details.

GNU gdb (GDB) 7.6
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-unknown-linux-gnu"...

      KERNEL: /usr/lib/debug/boot/vmlinux-3.13.0-48-generic
    DUMPFILE: /proc/kcore
        CPUS: 4
        DATE: Mon Jun 15 21:11:02 2015
      UPTIME: 00:29:43
LOAD AVERAGE: 0.15, 0.05, 0.06
       TASKS: 224
    NODENAME: gavin-Inspiron-7447
     RELEASE: 3.13.0-48-generic
     VERSION: #80~precise1hf00073670v20150319b2-Ubuntu SMP Thu Mar 19 11:01:43
     MACHINE: x86_64  (2793 Mhz)
      MEMORY: 3.9 GB
         PID: 2370
     COMMAND: "crash"
        TASK: ffff8800b30fb000  [THREAD_INFO: ffff8800b4a74000]
         CPU: 0
       STATE: TASK_RUNNING (ACTIVE)
</code></pre>

<p>可以嘗試看看下面的指令</p>

<pre><code>crash&gt; p *(struct kmem_cache *) kmalloc_caches
crash&gt; p saved_command_line
crash&gt; p uts_init_ns
crash&gt; log
crash&gt; kmem -S
crash&gt; help
</code></pre>

<p>當然會有疑惑，這能不能直接把 kernel 停下來，像是 gdb 一樣 debug？答案當然是不行。</p>
]]></content>
  </entry>
  
</feed>
